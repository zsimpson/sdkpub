#
# Jamrules file to build gsl
# (see http://www.freetype.org/jam/index.html)
#
# Copyright (C) 2004,2006  Jerry St.Clair
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#---------------------------------------------------------------------------

# The top of the tree to which installation is made
prefix = c:\\tools ;

# The subdir of $(prefix) for the gsl installation
INSTALL_ROOT = $(prefix)$(SLASH)libgsl-1.7 ;

# Comment to compile with debugging & assertions enabled
#NODEBUG = 1 ;

# The following hack is necessary because building of the libgsl dll 
# using MinGW is currently broken.  Data exported from the dll is not 
# handled properly by MinGW gcc 3.4.2 when the dll is built from the 
# static library.  In principle it would work by directly linking the 
# object files (as is now done for libgslcblas).  However, the link line
# generated by jam is too long.  Since gcc doesn't do response files
# at this point, no easy workaround could be found.  Suggestions would
# be welcomed.  This only applies to libgsl - libgslcblas is always built.
#
# Comment to use externally-built gsl dll's
BUILD_GSL_DLL = TRUE ;

# Set path to externally-built dll's.
# Comment if not present. Ignored if BUILD_GSL_DLL is not defined.
#EXTERNAL_RELEASE_DLL = .\\archive\\Release\\libgsl.dll ;
#EXTERNAL_DEBUG_DLL =   .\\archive\\libgsl_d.dll ;

# Top of source directory (list of elements of path)
srcdir_e = $(DOT) $(DOTDOT) ;
srcdir = [ FDirName $(srcdir_e) ] ;

#---------------------------------------------------------------------------
# Options from here on should not require routine tweaking

# Install directories - comment to not install that class of file
INSTALL_BIN_DIR      = $(INSTALL_ROOT)$(SLASH)bin ;
INSTALL_DOC_DIR      = $(INSTALL_ROOT)$(SLASH)doc ;
INSTALL_LIB_DIR      = $(INSTALL_ROOT)$(SLASH)lib ;
INSTALL_INCLUDE_DIR  = $(INSTALL_ROOT)$(SLASH)include ;
INSTALL_EXAMPLES_DIR = $(INSTALL_ROOT)$(SLASH)examples ;

# Build directory - will be qualified for compiler & build type
BUILD_DIR_ROOT = $(DOT) ;

# Comment for normal jam deletion of object files after building targets
KEEPOBJS = true ;

if $(NODEBUG)
{
  CCFLAGS += -DNDEBUG ;
  BUILD_SUBDIR = $(SLASH)Release ;
  GSL_LIB_NAME = libgsl ;
  CBLAS_LIB_NAME = libgslcblas ;
  GSL_IMPLIB_NAME = libgsl_dll ;
  CBLAS_IMPLIB_NAME = libgslcblas_dll ;
  EXTERNAL_DLL = $(EXTERNAL_RELEASE_DLL) ;
}
else
{
  BUILD_SUBDIR = $(SLASH)Debug ;
  GSL_LIB_NAME = libgsl_d ;
  CBLAS_LIB_NAME = libgslcblas_d ;
  GSL_IMPLIB_NAME = libgsl_d_dll ;
  CBLAS_IMPLIB_NAME = libgslcblas_d_dll ;
  EXTERNAL_DLL = $(EXTERNAL_DEBUG_DLL) ;
}

# template file to use to create config.h
GSL_CONFIG_H_TEMPLATE = config.h.in ;

if $(NT)
{
  # variables not set properly for Windows/Win9x in Jambase 2.3
  RM = del ;
  MV = move /Y ;

  # Windows-specific defines
  CCFLAGS = -D_X86_=1  -Dtry=__try -Dexcept=__except -DWIN32 -D_WIN32 ;
  C++FLAGS = $(CCFLAGS) ;

  SUFSHR = .dll ;

  if $(BCCROOT) || $(TOOLSET) = BORLANDC
  {
    GSL_CONFIG_H_TEMPLATE = config.h.bcc ;
    CCFLAGS   += -q -d -g0 -j0 -ff- -D_MSC_VER=7 ;
    CCWARN    = -w -w-8080 -w-8070 ;
    if $(NODEBUG)
    {
      CCDEBUG = -v- -O2 ;
    }
    else
    {
      CCDEBUG = -v -y -Od ;
    }
    BUILD_SUBDIR = $(BUILD_SUBDIR)$(SLASH)bcc ;
  }

  else if $(MSVCNT) || $(TOOLSET) = VISUALC
  {
    GSL_CONFIG_H_TEMPLATE = config.h.msvc ;
    CCFLAGS   += /Ze ;
    C++FLAGS  = $(CCFLAGS) ;
    CCWARN    = /W3 ;
    if $(NODEBUG)
    {
      CCDEBUG = /O2 ;
    }
    else
    {
      CCDEBUG = /Zi /Od ;
    }
    # Libraries are in different paths depending on VC version
    LINKFLAGS += /LIBPATH:$(VISUALC)\\lib /LIBPATH:$(VISUALC)\\PlatformSDK\\lib\\ ;
    LINKLIBS = advapi32.lib
               libc.lib
               oldnames.lib
               gdi32.lib
               user32.lib
               kernel32.lib ;
    BUILD_SUBDIR = $(BUILD_SUBDIR)$(SLASH)msvc ;
  }

  else if $(MINGW) || $(TOOLSET) = MINGW
  {
    GSL_CONFIG_H_TEMPLATE = config.h.mingw ;
    # uncomment to compile as strict ansi with full warnings
    #CCWARN = -ansi -Wall -W -pedantic -Wshadow ;

    if $(NODEBUG)
    {
      CCDEBUG = -O3 ;
    }
    else
    {
      CCDEBUG = -g -O0 ;
    }
    C++FLAGS  = $(CCFLAGS) ;
    BUILD_SUBDIR = $(BUILD_SUBDIR)$(SLASH)mingw ;
  }

  else if $(WATCOM) || $(TOOLSET) = WATCOM
  {
    GSL_CONFIG_H_TEMPLATE = config.h.watcom ;
    CCFLAGS += /fr ;
    CCWARN    = /wx ;
    if $(NODEBUG)
    {
      CCDEBUG = /ox ;
    }
    else
    {
      CCDEBUG = /od /d2 ;
    }
    BUILD_SUBDIR = $(BUILD_SUBDIR)$(SLASH)watcom ;
  }
}

else if $(OS) = LINUX || $(UNIX)
{
  SUFSHR = .so ;

  # uncomment to compile as strict ansi with full warnings
  #CCWARN = -ansi -Wall -W -pedantic -Wshadow ;
  if $(NODEBUG)
  {
    CCDEBUG = -O3 ;
  }
  else
  {
    CCDEBUG = -g -O0 ;
  }
  BUILD_SUBDIR = $(BUILD_SUBDIR)$(SLASH)linux ;
}

CCFLAGS  += $(CCWARN) $(CCDEBUG) $(DEBUG_MALLOC) ;
C++FLAGS  = $(CCFLAGS) ;
BUILD_DIR = $(BUILD_DIR_ROOT)$(BUILD_SUBDIR) ;
TMP_DIR   = $(BUILD_DIR)$(SLASH)temp ;

#----------------------------------------------------------
# GSL-specific rules
#----------------------------------------------------------

#----------------------------------------------------------
# AddToGslHeaders
#
# This rule compiles a list of headers in a
# subdirectory of the current directory.  It forms a
# relative path to the files in $(2) by appending the
# filenames to the relative path given in $(1).  The
# qualified filenames are then apended to the global
# variable GSL_HEADERS.
#----------------------------------------------------------
rule AddToGslHeaders
{
  GSL_HEADERS += $(srcdir)$(SLASH)$(1)$(SLASH)$(2) ;
  GSL_HEADERS_COPY += $(srcdir)$(SLASH)gsl$(SLASH)$(2) ;
}

#----------------------------------------------------------
# FConcatWithString
#
# Concatenates the strings in list $(1), inserting
# string $(2) between each one.  If $(2) is empty,
# the strings in list $(1) are just concatenated.
#----------------------------------------------------------
rule FConcatWithString
{
  local _s, _t _r ;

  _s = $(2[1]) ;
  _r = $(1[1]) ;

  for _t in $(1[2-])
  {
    if $(_s)
      { _r = $(_r)$(_s)$(_t) ; }
    else
      { _r = $(_r)$(_t) ; }
  }

  return $(_r) ;
}

#----------------------------------------------------------
# FStripDots
#
# Removes strings of $(DOT) and $(DOTDOT) from a list.
#----------------------------------------------------------
rule FStripDots
{
  local _t _r ;

  for _t in $(1[1-])
  {
    if ! $(_t) in $(DOT) $(DOTDOT)
    {
      _r = $(_r) $(_t) ;
    }
  }

  return $(_r) ;
}

#----------------------------------------------------------
# AddToLibrary
#
# This rule compiles source files in a specified relative
# location to object files, then adds them to a specified
# library.  This rule modifies the names of the object
# files with a string derived from the relative path.
# This allows easy addition of files having the same name
# in different source directories.  Although $(DOT) and
# $(DOTDOT) are valid elements of the relative path, they
# are not included in the name derivation.  This rule
# also adds the files to the library immediately.  This
# avoids the problem of archive commands becoming too
# long for the shell in large libraries.
#
# The object files are stored in the location held in
# global variable TMP_DIR, while the library is stored
# in the location held in BUILD_DIR.  If either variable
# is empty, the relocation is not performed.
#
# Parameters:
#
# 1 - Root name of library to add objects to
# 2 - elements of relative path to source files (d1 d2 d3 ...)
# 3 - source files to compile and archive
#----------------------------------------------------------
rule AddToLibrary
{
  local i, _path, _lib, _prefix, LIB_OBJECTS ;

  _lib = $(1[1]) ;
  _path = [ FDirName $(2) ] ;
  _prefix = [ FConcatWithString [ FStripDots $(2) ] : _ ] ;
  _LIB_OBJECTS = ;

  LOCATE_TARGET = $(TMP_DIR) ;

  for i in $(3)
  {
    local _o =  [ FConcatWithString $(_prefix) $(i) : _ ] ;
    _o = $(_o:S=$(SUFOBJ)) ;
    DEPENDS $(_o) : files ;

    LIB_OBJECTS += $(_o) ;
    LIB_OBJECTS_ALL += $(_o) ;
    Object $(_o) : $(_path)$(SLASH)$(i) ;
  }

  for i in $(3)
  {
    local _ob =  [ FConcatWithString d $(_prefix) $(i) ] ;
    _ob = $(_ob:S=$(SUFOBJ)) ;
    DEPENDS $(_ob) : files ;

    DLL_OBJECTS_ALL += $(_ob) ;
    if $(BUILD_GSL_DLL)
    {
      Object $(_ob) : $(_path)$(SLASH)$(i) ;
      ObjectCcFlags $(_ob) : -DGSL_DLL -DDLL_EXPORT ;
    }
  }

  LibraryFromObjects $(_lib) : $(LIB_OBJECTS) ;
  MakeLocate $(_lib:S=$(SUFLIB)) : $(BUILD_DIR) ;
}

#----------------------------------------------------------
# AddObjectToCblasDll
#
# This rule compiles source files for the cblas dll
# and stores the object name in a global variable for
# use in building the dll later.  The object files are 
# stored in $(BUILD_DIR)$(SLASH)cblas.
#
# Parameters:
#
# 1 - source files to compile and archive
#----------------------------------------------------------
rule AddObjectToCblasDll
{
  for i in $(1)
  {
    local _o =  cblas_$(i:B)_dll$(SUFOBJ) ;
    MakeLocate $(_o) : $(BUILD_DIR)$(SLASH)cblas ;

    CBLAS_DLL_OBJECTS += $(_o) ;
    Object $(_o) : $(i) ;
    CCFLAGS on $(_o) += -DGSL_DLL -DDLL_EXPORT ;
  }
}

#----------------------------------------------------------
# BuildGslTest
#
# This rule compiles the test sources in a specified
# relative location to object files, then links them
# into 2 executables.  One is linked with the static
# libgsl and libgslcblas libraries, while the other is
# linked and run with the dynamic libraries.  The
# names of the executables are constructed as
# test_PATH_TO_SOURCES$(SUFEXE) and
# test_PATH_TO_SOURCES_dll$(SUFEXE), respectively.
#
# This rule modifies the names of the object files with 
# a string derived from the relative path.  This allows 
# source files having the same name in different source 
# directories to share a common location for object files.
# Although $(DOT) and $(DOTDOT) are valid elements in the 
# relative path, they are not included in the name
# derivation.  
#
# The object files are stored in the location held in
# global variable TMP_DIR, while the library is stored
# in the location held in BUILD_DIR.  If either variable
# is empty, the relocation is not performed.
#
# Parameters:
#
# 1 - elements of relative path to source files (d1 d2 d3 ...)
# 2 - source files to compile and link
#----------------------------------------------------------
rule BuildGslTest
{
  local i , _path, _prefix, TEST_OBJS ;

  _path = [ FDirName $(1) ] ;
  _prefix = [ FConcatWithString [ FStripDots $(1) ] : _ ] ;

  TEST_OBJS = ;

  for i in $(2)
  {
    local _o = $(_prefix)_$(i) ;
    _o = $(_o:S=$(SUFOBJ)) ;
    MakeLocate $(_o) : $(TMP_DIR) ;

    TEST_OBJS += $(_o) ;
    Object $(_o) : $(_path)$(SLASH)$(i) ;
  }

  local _e1 = test_$(_prefix)$(SUFEXE) ;
  local _e2 = test_$(_prefix)_dll$(SUFEXE) ;

  MainFromObjects $(_e1) : $(TEST_OBJS) ;
  LinkLibraries $(_e1) : $(GSL_LIB_NAME)$(SUFLIB) $(CBLAS_LIB_NAME)$(SUFLIB) ;
  MakeLocate $(_e1) : $(BUILD_DIR) ;
  DEPENDS $(_e1) : $(GSL_LIB_NAME)$(SUFLIB) $(CBLAS_LIB_NAME)$(SUFLIB) ;

  MainFromObjects $(_e2) : $(TEST_OBJS) ;
  MakeLocate $(_e2) : $(BUILD_DIR) ;
  if $(BUILD_GSL_DLL)
  {
    LINKLIBS on $(_e2) +=
      $(BUILD_DIR)$(SLASH)$(GSL_LIB_NAME)$(SUFSHR)
      $(BUILD_DIR)$(SLASH)$(CBLAS_LIB_NAME)$(SUFSHR)
      ;
    DEPENDS $(_e2) : $(GSL_LIB_NAME)$(SUFSHR) $(CBLAS_LIB_NAME)$(SUFSHR) ;
  }
  else
  {
    LINKLIBS on $(_e2) +=
      $(EXTERNAL_DLL)
      $(BUILD_DIR)$(SLASH)$(CBLAS_LIB_NAME)$(SUFSHR)
      ;
    DEPENDS $(_e2) : $(CBLAS_LIB_NAME)$(SUFSHR) ;
  }
}

#----------------------------------------------------------
# MakeImportLibrary
#
# This is a dummy rule.  Import libraries are built in
# the dll linking directive.  However, jam doesn't know
# that, so we provide a rule which does nothing more
# than define a dependency.
#
# Parameters:
#
# 1 - name of the dll
# 2 - name of the import library
#----------------------------------------------------------
rule MakeImportLibrary
{
  DEPENDS $(>) : $(<) ;
  LOCATE on $(>) = $(BUILD_DIR) ;
}

