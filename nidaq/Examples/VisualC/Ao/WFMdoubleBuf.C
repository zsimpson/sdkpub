/*********************************************************************
*
* Example program: 
*    WFMdoubleBuf.c
*
* Description: 
*    Continuously outputs a waveform from one analog output channel,
*     using internal timing (uses low-level NI-DAQ functions)
*
* Example Category: 
*    AO
*
* Example Task Types: 
*    BUF, 1CH, CONT, ASYNC, INTTIM, INTTRIG
*
* List of key parameters: 
*    iDBmodeON, iOldDataStop, iPartialTransferStop, ulIterations,
*     iWFMstopped
*
*    [Since variables are hardcoded, there is no guarantee that this
*     program will work for your setup.  This example is simply
*     presented as a code snippet of how you can use NI-DAQ functions
*     to perform a task.]
*
* List of NI-DAQ Functions used in this example: 
*    Timeout_Config, NIDAQErrorHandler, NIDAQMakeBuffer, WFM_DB_Config,
*     WFM_Group_Setup, WFM_Scale, WFM_Load, WFM_Rate, WFM_ClockRate,
*     WFM_Group_Control, WFM_DB_HalfReady, WFM_DB_Transfer, NIDAQYield,
*     WFM_Check, AO_VWrite
*
*    [NOTE: For further details on each NI-DAQ function, please refer
*     to the NI-DAQ On-Line Help (NIDAQPC.HLP).]
*
* Pin Connection Information: 
*    The analog output signal will be available at AO channel 0. The
*     default analog output mode for the DAQ device will be used.
*
*    [For further I/O connection details, please refer to your hardware
*     User Manual.]
*
*    [For further details on how to run this example, please refer to
*     the NI-DAQ Examples On-Line Help (NIDAQEx.HLP).]
*
*********************************************************************/
/*
 * Includes: 
 */

#include "nidaqex.h"


/*
 * Main: 
 */

void main(void)
{
    /*
     * Local Variable Declarations: 
     */

    i16 iStatus = 0;
    i16 iRetVal = 0;
    i16 iDevice = 1;
    i16 iGroup = 1;
    i16 iNumChans = 1;
    i16 iChan = 0;
    static i16 piChanVect[1] = {0};
    i16 iDBmodeON = 1;
    i16 iDBmodeOFF = 0;
    i16 iOldDataStop = 1;
    i16 iPartialTransferStop = 0;
    static f64 pdBuffer[32768] = {0};
    static i16 piBuffer[32768] = {0};
    u32 ulCount = 32768;
    u32 ulHalfCount = 16384;
    u32 ulIterations = 0;
    i16 iFIFOMode = 0;
    f64 dUpdateRate = 10000.0;
    i16 iUnits = 0;
    i16 iUpdateTB = 0;
    u32 ulUpdateInt = 0;
    i16 iWhichClock = 0;
    i16 iDelayMode = 0;
    i16 iOpSTART = 1;
    i16 iOpCLEAR = 0;
    i16 iHalfReady = 0;
    i16 iLoopCount = 0;
    i16 iHalfBufsToWrite = 10;
    i16 iIgnoreWarning = 0;
    i32 lTimeout = 180;
    i16 iWFMstopped = 0;
    u32 ulItersDone = 0;
    u32 ulPtsDone = 0;
    i16 iYieldON = 1;

    /* This sets a timeout limit (#Sec * 18ticks/Sec) so that if there
     is something wrong, the program won't hang on the WFM_DB_Transfer
     call. */

    iStatus = Timeout_Config(iDevice, lTimeout);

    iRetVal = NIDAQErrorHandler(iStatus, "Timeout_Config",
     iIgnoreWarning);

    iStatus = NIDAQMakeBuffer(pdBuffer, ulCount, WFM_DATA_F64);

    if (iStatus == 0) {


        /* If buffer was made correctly, then output it. */

        iStatus = WFM_DB_Config(iDevice, iNumChans, piChanVect,
         iDBmodeON, iOldDataStop, iPartialTransferStop);

        iRetVal = NIDAQErrorHandler(iStatus, "WFM_DB_Config",
         iIgnoreWarning);

        iStatus = WFM_Group_Setup(iDevice, iNumChans, piChanVect,
         iGroup);

        iRetVal = NIDAQErrorHandler(iStatus, "WFM_Group_Setup",
         iIgnoreWarning);

        iStatus = WFM_Scale(iDevice, iChan, ulCount, 1.0, pdBuffer,
         piBuffer);

        iRetVal = NIDAQErrorHandler(iStatus, "WFM_Scale",
         iIgnoreWarning);

        /* NOTE FOR DSA devices... DSA devices can format samples in a
         left-justified format in 32-bit data words. This means that the most
         significant bits of the data word contain the bits generated by the
         converter. When allocating data buffers, be sure to account for the
         32-bit data width. Even though a number of DAQ/SCAN/WFM functions are
         declared to accept pointers to 16-bit data buffers, you should pass
         pointers to 32-bit data buffers. */
        

        /* Also for DSA devices, remember to call AO_Change_Parameter
         to enable the analog output. */

        iStatus = WFM_Load(iDevice, iNumChans, piChanVect, piBuffer,
         ulCount, ulIterations, iFIFOMode);

        iRetVal = NIDAQErrorHandler(iStatus, "WFM_Load",
         iIgnoreWarning);

        /* NOTE: If you are using a DSA device, call WFM_Set_Clock
         instead.  Refer to NI-DAQ Function Reference Manual for details. */
        

        iStatus = WFM_Rate(dUpdateRate, iUnits, &iUpdateTB,
         &ulUpdateInt);

        iRetVal = NIDAQErrorHandler(iStatus, "WFM_Rate",
         iIgnoreWarning);

        iStatus = WFM_ClockRate(iDevice, iGroup, iWhichClock,
         iUpdateTB, ulUpdateInt, iDelayMode);

        iRetVal = NIDAQErrorHandler(iStatus, "WFM_ClockRate",
         iIgnoreWarning);

        printf(" The waveform should be output at a rate of %lf updates/sec.\n", dUpdateRate);

        iStatus = WFM_Group_Control(iDevice, iGroup, iOpSTART);
        

        iRetVal = NIDAQErrorHandler(iStatus,
         "WFM_Group_Control/START", iIgnoreWarning);

        while ((iLoopCount < iHalfBufsToWrite) && (iStatus == 0)) {

            

            iStatus = WFM_DB_HalfReady(iDevice, iNumChans, piChanVect,
             &iHalfReady);

            if ((iHalfReady == 1) && (iStatus == 0)) {

                

                /* Update next half buffer.  WFM_DB_Transfer will
                 return upon updating the circular buffer, but it does NOT indicate
                 that the actual data has been generated. */
                

                /* HINT: You actually can dynamically change the
                 output buffer here!  This example is reusing the same buffer to
                 ensure simplicity of the source code. */
                

                /* NOTE FOR DSA devices... DSA devices can format
                 samples in a left-justified format in 32-bit data words. This means
                 that the most significant bits of the data word contain the bits
                 generated by the converter. When allocating data buffers, be sure to
                 account for the 32-bit data width. Even though a number of
                 DAQ/SCAN/WFM functions are declared to accept pointers to 16-bit data
                 buffers, you should pass pointers to 32-bit data buffers. */
                
                
                

                /* Also for DSA devices, remember to call
                 AO_Change_Parameter to enable the analog output. */
                

                iStatus = WFM_DB_Transfer(iDevice, iNumChans,
                 piChanVect, piBuffer, ulHalfCount);

                iRetVal = NIDAQErrorHandler(iStatus,
                 "WFM_DB_Transfer", iIgnoreWarning);

                ++iLoopCount;

                printf(" %d Half buffers generated.\n", iLoopCount);

            }
            else {

                iRetVal = NIDAQErrorHandler(iStatus,
                 "WFM_DB_HalfReady", iIgnoreWarning);

            }


            iRetVal = NIDAQYield(iYieldON);

        }


        /* If 'iOldDataStop' is 1, then NI-DAQ will stop the waveform
         generation when the last updated half buffer is actually completed.
         This is to prevent underflow conditions.  Check if 'iWFMstopped' is
         set in WFM_Check to make sure the last half buffer is 'really'
         completed. */

        /* If 'iOldDataStop' is 0, NI-DAQ will keep on outputting the
         last half buffer, so the waveform generation will never stop.  In
         that case, you can forcefully stop it with WFM_Group_Control/CLEAR.
         */

        if (iOldDataStop == 1) {


            do {


                /* When the last half buffer is actually done,
                 WFM_Check will return an underflow error, so don't check for errors
                 on purpose. */

                iStatus = WFM_Check(iDevice, iChan, &iWFMstopped,
                 &ulItersDone, &ulPtsDone);

                iRetVal = NIDAQYield(iYieldON);

            } while (iWFMstopped != 1);


        }


        /* CLEANUP - Don't check for errors on purpose. */

        /* Set WFM group back to initial state. */

        iStatus = WFM_Group_Control(iDevice, iGroup, iOpCLEAR);
        

        /* Set DB mode back to initial state. */

        iStatus = WFM_DB_Config(iDevice, iNumChans, piChanVect,
         iDBmodeOFF, 0, 0);

        /* Set output at 0 volts. */

        iStatus = AO_VWrite(iDevice, iChan, 0.0);

        printf(" The waveform generation is done!\n");

    }
    else {

        printf(" The buffer was not made correctly. Check the parameters for NIDAQMakeBuffer.\n");

    }


    /* Disable timeouts. */

    iStatus = Timeout_Config(iDevice, -1);


}

/* End of program */
